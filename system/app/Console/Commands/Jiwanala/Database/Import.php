<?php

namespace App\Console\Commands\Jiwanala\Database;

use Illuminate\Console\Command;

class Import extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'jn-db:import 
		{--remote				: use remote connection}
		{--query-limit= 		: query limit. default 1000 records}
		{--import-version= 		: signature time for export key. Refer to directory name in storage/app/database/}
		{--import-mode= 		: SQL or JSON. Default JSON}
	';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Run sql script generated by jiwanala-db:export in storage folder';
	
	protected $host = 'localhost';
	protected $driver = 'mysql';
	protected $username;
	protected $password;
	protected $dir = '';
	protected $storagePath = 'database';
	
	/**
     * Create a new command instance.
     *
     * @return void
     */
    public function __construct()
    {
        parent::__construct();
    }
	
	function getVersion(){
		$version = $this->option('import-version');
		if ($version){
			return $version;
		}
		
		//no given version		
		//get latest version folder
		$versions = [];
		foreach(\Storage::disk('local')->directories($this->storagePath) as $dir){
			$versions[] = str_replace('database/','',$dir);
		}
		return $versions[count($versions)-1];
	}

    /**
     * Execute the console command.
     *
     * @return mixed
     */
    public function handle(){
		ini_set('max_execution_time', 0);
		set_time_limit(0);
		
		//check username & password
		$mode = $this->getMode();
		$this->infoStart();
		
		$database = [];
		foreach($this->getSchemas() as $schema){
			$tables = $this->getAllSchemaTable($schema);
			foreach($tables as $table){
				$database[$schema][] = $table;
			}
		}
		
		foreach($database as $schema=>$tables){
			foreach($tables as $table){			
				if ($this->isFileExists($schema, $table)){
					$schemaInfo = array_combine(['schema','table'],[$schema, $table]);
					if ($mode == 'sql'){					
						//read & import sql 
						$this->infoRead($file);
						$this->getConnection($schemaInfo['schema'])->unprepared($this->read($file));
						$this->infoReadSuccess();
					}
				
					//json
					else{
						$json = json_decode($this->read($schema, $table), true);
						$this->handleJSON($this->getConnection($schemaInfo['schema']), $json);
					}
				}
			}
		}
			
		$this->infoEnd();
    }
	
	function handleJSON($db, $json){
		if (isset($json['records']) && count($json['records'])>0){
			$str = $json['database']['schema'].'.'.$json['database']['table'];
			$this->infoRead($str.' : '.count($json['records']).' records');
			
			$rcount = count($json['records']);
			
			if ($this->getConnection($json['database']['schema'])->getConfig('host') == 'localhost'){
				$db->statement('SET GLOBAL max_allowed_packet=1073741824');				
			}
			$db->statement('SET FOREIGN_KEY_CHECKS=0');
			$db->beginTransaction();
			for($i=0; $i<$rcount; $i++){
				//check if column value type need to be encode to base64
				foreach($json['columns'] as $col=>$type){
					if (str_contains($type, 'blob')){
						$json['records'][$i][$col] = base64_decode($json['records'][$i][$col]);
					}
				}
				
				//insert
				
				$db->table($json['database']['schema'].'.'.$json['database']['table'])->insert($json['records'][$i]);
			}
			$db->commit();
			$db->statement('SET FOREIGN_KEY_CHECKS=1');
			$this->infoReadSuccess();
		}
	}
	
	function infoStart(){
		echo PHP_EOL .
			"\033[36m". "Start "."\033".
			"\033[37m". "Import "."\033". PHP_EOL .
			"\033[37m". "Use Version : "."\033".
			"\033[36m". $this->getVersion() ."\033".
			"[0m". PHP_EOL;
	}
	
	function infoEnd(){
		echo "\033[36m". "Done "."\033".
			"[0m". "Import ". PHP_EOL;
	}
	
	function infoRead($str){
		echo "\033[37m". "Importing "."\033".
			"\033[32m". $str ."\033";
	}
	
	function infoReadSuccess(){
		echo "\033[37m". " : "."\033".
			"\033[36m". "Success"."\033".
			"[0m". PHP_EOL;
	}
	
	function getConnection($schema){
		return $this->option('remote')? 
			$this->getRemoteConnection($schema, true) : 
			$this->getLocalConnection($schema);
	}
	
	function getRemoteConnection($schema){ 
		$key = 'remote_'.$schema;
		config(['database.connections.'.$key => [
				'driver' => 	env('DB_REMOTE_DRIVER'),
				'host' => 		env('DB_REMOTE_HOST'),
				'username' => 	env('DB_REMOTE_USERNAME'),
				'password' => 	env('DB_REMOTE_PASSWORD'),
				'database' => 	$schema,
			]]);
		return \DB::connection($key);
	}
	function getLocalConnection($schema){ 
		$connections = config('database.connections');
		foreach($connections as $key=>$con){
			if ($con['database'] == $schema){
				return \DB::connection($key);
			}
		}
		return false;
	}
	
	function getAllSchemaTable($schema){
		//we need to sort the sql dump base on table creation date
		//to avoid export error
		$tables = $this->getConnection($schema)
			->table('information_schema.tables')
			->select(['table_name', 'create_time'])
			->where('table_schema',$schema)
			->orderBy('create_time','asc')
			->get();
			
		$tableList = [];
		foreach($tables as $table){
			$tableList[] = $table->table_name;
		}
		return $tableList;
	}
	
	function getSchemas(){
		$connections = config('database.connections');
		$db = [];
		foreach($connections as $key=>$con){
			$db[] = $con['database'];
		}
		return $db;
	}
	
	function getFilePath($schema, $table){
		return $this->storagePath.'/'.
				$this->getVersion().'/'.
				$this->getVersion().'_'.$schema.'_'.$table.'.sql';
	}
	
	function isFileExists($schema, $table){
		return \Storage::disk('local')->exists($this->getFilePath($schema, $table));
	}
	
	function read($schema, $table){
		return \Storage::disk('local')->read($this->getFilePath($schema, $table));
	}
	
	function getMode(){
		return $this->option('import-mode')? $this->option('import-mode') : 'json';
	}
}
